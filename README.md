# 🚀 Go API Boilerplate

A production-ready Go API boilerplate with security best practices, Docker containerization, and monitoring built-in. This project aims to give you a solid foundation to build upon, so you can focus on your business logic instead of infrastructure setup.

## ✨ Features

- **🔐 Security First**: JWT authentication, rate limiting, SSL/TLS, security headers
- **📊 Monitoring**: Prometheus metrics, health checks, structured logging
- **🐳 Containerized**: Docker Compose with multi-stage builds and security hardening
- **🗄️ Database Ready**: PostgreSQL with SSL and Redis for caching
- **🔧 Developer Friendly**: Hot reload, comprehensive middleware, clean architecture
- **🛡️ Production Ready**: Secrets management, non-root containers, network isolation

## 📋 Prerequisites

Before getting started, make sure you have:

- [Docker](https://docs.docker.com/get-docker/) and [Docker Compose](https://docs.docker.com/compose/install/)
- Either [PowerShell](https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell) (Windows) or Bash (Unix/Linux/macOS) for the migration script
- A text editor or IDE of your choice

## 🚀 Quick Start

### 1. Clone and Navigate

```bash
git clone <your-repo-url>
cd <your-project-directory>
```

### 2. Configure Environment

Copy the example environment file and customize it:

```bash
cp .env.example .env  # If you have an example file
# Or simply edit the existing .env file
```

**Important**: Update these values in your `.env` file:

```bash
# Security - PLEASE CHANGE THESE!
APP_SECRET="your-super-secret-jwt-key-at-least-32-characters-long"
POSTGRES_PASSWORD="your-strong-postgres-password"
REDIS_PASSWORD="your-strong-redis-password"

# Environment
APP_ENV=development  # or 'production'

# Database connection will be auto-constructed, but you can override:
# DATABASE_URL="postgres://apiuser:your-password@db:5432/apidb?sslmode=require"
```

### 3. Create Docker Secrets

We provide scripts to convert your `.env` variables into Docker secrets (mimicking AWS Secrets Manager or similar):

**For Windows (PowerShell):**
```powershell
./migrate.ps1
```

**For Unix/Linux/macOS (Bash):**
```bash
chmod +x migrate.sh
./migrate.sh
```

This creates individual secret files in the `./secrets/` directory that Docker Compose will mount securely into your containers.

### 4. Start Everything

```bash
docker-compose up -d
```

This will start:
- **API**: Your Go application (internally on port 8080)
- **Database**: PostgreSQL with SSL
- **Cache**: Redis
- **Proxy**: Nginx with SSL termination (ports 80→443 redirect, 443 for HTTPS)
- **Monitoring**: Prometheus (port 9090)

### 5. Test Your API

```bash
# Health check
curl -k https://localhost/health

# Get a JWT token
curl -k -X POST https://localhost/auth \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"password"}'

# Use the token for protected routes
curl -k https://localhost/api/v1/protected \
  -H "Authorization: Bearer YOUR_JWT_TOKEN_HERE"
```

## 🏗️ Project Structure

```
├── api-service/                 # Go application
│   ├── cmd/api/main.go         # Application entry point
│   ├── internal/
│   │   ├── config/             # Configuration management
│   │   ├── database/           # Database connection
│   │   ├── handlers/           # HTTP handlers
│   │   ├── middleware/         # Custom middleware
│   │   └── router/             # Route definitions
│   ├── Dockerfile              # Multi-stage Docker build
│   ├── go.mod & go.sum        # Go dependencies
├── nginx/                      # Reverse proxy configuration
├── prometheus/                 # Monitoring configuration
├── certs/                      # SSL certificates (self-signed for dev)
├── secrets/                    # Generated by migrate.ps1 or migrate.sh
├── scripts/                    # Database initialization scripts
├── docker-compose.yml          # Container orchestration
├── .env                        # Environment variables
├── migrate.ps1                # Converts .env to Docker secrets (Windows)
└── migrate.sh                 # Converts .env to Docker secrets (Unix/Linux)
```

## 🛠️ Adding New Routes

Here's how to add a new endpoint to your API:

### 1. Create a Handler

Add your business logic in `api-service/internal/handlers/handlers.go`:

```go
// GetUsers handles GET /api/v1/users
func (h *Handlers) GetUsers(w http.ResponseWriter, r *http.Request) {
    // Get user ID from JWT context (if needed)
    userID, ok := r.Context().Value(config.UserIDKey).(string)
    if !ok {
        writeError(w, h.app, http.StatusInternalServerError, "Could not process user information")
        return
    }

    // Your business logic here
    users := []map[string]interface{}{
        {"id": 1, "name": "John Doe", "email": "john@example.com"},
        {"id": 2, "name": "Jane Smith", "email": "jane@example.com"},
    }

    writeSuccess(w, h.app, users, "Users retrieved successfully")
}
```

### 2. Register the Route

Add the route in `api-service/internal/router/router.go`:

```go
func Setup(app *config.Application) http.Handler {
    // ... existing code ...

    // Protected routes
    protected := router.PathPrefix("/api/v1").Subrouter()
    protected.Use(mw.JWT)
    protected.HandleFunc("/protected", h.Protected).Methods("GET")
    protected.HandleFunc("/users", h.GetUsers).Methods("GET")        // ← Add this line
    
    return router
}
```

### 3. Test Your New Route

```bash
# Get a token first
TOKEN=$(curl -k -s -X POST https://localhost/auth \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"password"}' | jq -r '.data.token')

# Test your new endpoint
curl -k https://localhost/api/v1/users \
  -H "Authorization: Bearer $TOKEN"
```

## 🔧 Development Workflow

### Making Changes

1. **Modify Code**: Edit files in `api-service/`
2. **Rebuild**: `docker-compose up --build api` (rebuilds just the API container)
3. **Test**: Use the endpoints to verify your changes

### Adding Dependencies

```bash
# Navigate to the Go module
cd api-service

# Add a new dependency
go get github.com/some/package

# Update go.mod and go.sum, then rebuild
docker-compose up --build api
```

### Database Changes

For database schema changes, you'd typically:

1. Add migration scripts to `scripts/`
2. Mount them in `docker-compose.yml`
3. Run them during container startup or manually

### Environment-Specific Configuration

- **Development**: Uses self-signed certificates, debug logging
- **Production**: Update `APP_ENV=production` in `.env`, use real certificates

## 🔒 Security Features

This boilerplate includes several security measures:

- **🔐 JWT Authentication**: Secure token-based auth
- **🚦 Rate Limiting**: Prevents abuse (configurable per IP)
- **🛡️ Security Headers**: HSTS, CSP, X-Frame-Options, etc.
- **🔒 SSL/TLS**: HTTPS everywhere with modern cipher suites
- **👤 Non-Root Containers**: All services run as non-privileged users
- **📁 Read-Only Filesystems**: Containers can't write to their root filesystems
- **🌐 Network Isolation**: Internal networks for database/cache communication
- **🗝️ Secrets Management**: Credentials stored in Docker secrets, not environment variables

## 📊 Monitoring & Health Checks

### Health Endpoints

- **API Health**: `GET /health` - Shows database and Redis connectivity
- **Metrics**: `GET /metrics` - Prometheus metrics (restricted to internal networks)

### Prometheus Monitoring

Access Prometheus at `http://localhost:9090` to:

- Monitor API performance and error rates
- Set up alerts for high latency or errors
- View system metrics and resource usage

### Logs

View structured logs with:

```bash
# All services
docker-compose logs -f

# Just the API
docker-compose logs -f api

# Database logs
docker-compose logs -f db
```

## 🚨 Troubleshooting

### Common Issues

**"Connection refused" errors:**
```bash
# Check if all services are running
docker-compose ps

# Check service logs
docker-compose logs api
```

**SSL certificate warnings:**
- The included certificates are self-signed for development
- For production, replace certificates in `certs/` with valid ones

**Database connection issues:**
```bash
# Check database health
docker-compose exec db pg_isready -U apiuser -d apidb

# View database logs
docker-compose logs db
```

**Permission errors:**
```bash
# Ensure secrets were created properly
ls -la secrets/

# Recreate secrets if needed
./migrate.ps1    # Windows
# OR
./migrate.sh     # Unix/Linux/macOS
```

### Resetting Everything

```bash
# Stop and remove all containers, networks, and volumes
docker-compose down -v

# Remove generated secrets
rm -rf secrets/

# Start fresh
./migrate.ps1    # Windows
# OR  
./migrate.sh     # Unix/Linux/macOS

docker-compose up -d
```

## 🤝 Contributing

We'd love your help making this boilerplate even better! Here are some ways to contribute:

1. **🐛 Report Issues**: Found a bug? Please open an issue
2. **💡 Suggest Features**: Have an idea? We'd love to hear it
3. **📖 Improve Documentation**: Help make this README even clearer
4. **🔧 Submit PRs**: Code improvements, bug fixes, new features

## 📝 License

This project is open source and available under the [MIT License](LICENSE).

## 🙏 Acknowledgments

This boilerplate stands on the shoulders of giants. Special thanks to:

- The Go community for excellent tooling and libraries
- Docker for making containerization accessible
- The security community for best practices and guidance

---

**Happy coding!** 🎉 

If you run into any issues or have questions, don't hesitate to open an issue. We're here to help make your development experience as smooth as possible.